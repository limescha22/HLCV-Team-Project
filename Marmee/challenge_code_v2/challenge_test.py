# -*- coding: utf-8 -*-
"""
    Changelog:
    - v3:
        - Changed output file format.
    - v4:
        - Added date to output file name.
        - Only considers a split if the corresponding folder exists.

    DO NOT EDIT THIS FILE.
    EDITS TO THIS FILE ARE NOT CONSIDERED.
    
    This file is imported by your test evaluation implementation
    (see challenge_train.py) and will be run to test your model.
    
    To test whether your submission is working (and as a sanity check),
    you can copy & paste the validation split into a "test" folder.

"""

from abc import abstractmethod
from typing import final
import torch, torchvision
import os

class Test:
    @abstractmethod
    def __init__(self):
        pass
    
    @abstractmethod
    def create_model(self):
        pass
    
    @abstractmethod
    def create_transform(self):
        pass
    
    @final
    def test_model(
            self,
            root = "val",
            device = "cuda",
            weights = "model.torch"
        ):
        model = self.create_model()
        assert issubclass(model.__class__, torch.nn.Module)
        num_par = sum([torch.prod(torch.tensor(p.shape)) for p in model.parameters()]).item()
        assert num_par <= 10_000
        
        state_dict = torch.load(
            weights,
            weights_only = True,
            map_location = "cpu"
        )
        model.load_state_dict(state_dict, strict=False)
        model = model.to(device)
        model.eval()
        
        results = dict()
        
        for split in ["train", "val", "test"]:
            root_split = os.path.join(root, split)
            if os.path.isdir(root_split):
                dataset = torchvision.datasets.ImageFolder(
                    root = root_split,
                    transform = self.create_transform()
                )
                
                dataloader = torch.utils.data.DataLoader(
                    dataset = dataset,
                    batch_size = 1024,
                    shuffle = False,
                    num_workers = 1
                )
                
                correct = 0
                total = 0
                
                cm = torch.zeros(10,10)
                
                with torch.no_grad():
                    for images, labels in dataloader:
                        images, labels = images.to(device), labels.to(device)
                        outputs = model(images)
                        _, preds = torch.max(outputs, 1)
                        correct += (preds == labels).sum().item()
                        total += labels.size(0)
                        for i, j in torch.stack([preds, labels]).cpu().T.tolist():
                            cm[i,j] += 1
                
                results[split] = dict(acc=correct/total, cm=cm/total*10)
        
        return results



if __name__ == "__main__":
    from challenge_train import Trainer  # CHANGED: Removed trainval. prefix
    import datetime
    Trainer.test_model = Test.test_model
    
    trainer = Trainer()
    device = "cuda" if torch.cuda.is_available() else "cpu"
    results = trainer.test_model(device=device)
    
    lines = []
    for split in ["train", "val", "test"]:
        if split in results:
            lines += [f"#### {split}: {results[split]['acc']:.3f} ####"]
            cm = results[split]["cm"]
            
            A = [[f"{float(x):.2f}" for x in r.tolist()] for r in cm]
            n = len(A)
            W = [max(len(A[i][j]) + (2 if i==j else 0) for i in range(n)) for j in range(n)]
            def cell(i,j):
                return f" [{A[i][j]:>{W[j]-2}}] " if i==j else f"{A[i][j]:>{W[j]}}  "
            h = "+" + "+".join("-"*(w+2) for w in W) + "+"
            lines += [h]
            lines += ["|" + "|".join(cell(i,j) for j in range(n)) + "|" for i in range(n)]
            lines += [h,""]
    
    with open(f"result_{datetime.date.today()}.txt", "w") as f:
        f.write("\n".join(lines))